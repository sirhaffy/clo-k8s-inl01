name: Deploy Infrastructure to Azure

on:
  push:
    branches: [master, main] # Trigger on merge to main branches
    paths: ['terraform/**', '.github/workflows/deploy-infrastructure.yml', 'argocd/**', 'helm/**']
  workflow_dispatch:
    inputs:
      terraform_action:
        description: 'Terraform action'
        required: true
        default: 'plan'
        type: choice
        options: [plan, apply, destroy]

env:
  ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
  ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
  ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
  ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
  TF_VAR_environment: 'prod'
  TF_VAR_location: ${{ secrets.AZURE_LOCATION }}
  TF_VAR_resource_group_name: ${{ secrets.TF_BACKEND_RESOURCE_GROUP }}
  TF_VAR_naming_prefix: ${{ secrets.PROJECT_PREFIX }}
  TF_BACKEND_RESOURCE_GROUP: ${{ secrets.TF_BACKEND_RESOURCE_GROUP }}
  TF_BACKEND_STORAGE_ACCOUNT: ${{ secrets.TF_BACKEND_STORAGE_ACCOUNT }}
  TF_BACKEND_CONTAINER: ${{ secrets.TF_BACKEND_CONTAINER }}

jobs:
  setup-backend:
    name: Setup Backend
    runs-on: ubuntu-latest
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ensure Backend Infrastructure
        run: |
          # Resource Group
          if ! az group show --name "${{ env.TF_BACKEND_RESOURCE_GROUP }}" &>/dev/null; then
            echo "Creating resource group..."
            az group create --name "${{ env.TF_BACKEND_RESOURCE_GROUP }}" --location "${{ env.TF_VAR_location }}"
          else
            echo "Resource group already exists"
          fi

          # Storage Account
          if ! az storage account show --name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" --resource-group "${{ env.TF_BACKEND_RESOURCE_GROUP }}" &>/dev/null; then
            echo "Creating storage account..."
            az storage account create \
              --name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
              --resource-group "${{ env.TF_BACKEND_RESOURCE_GROUP }}" \
              --location "${{ env.TF_VAR_location }}" \
              --sku Standard_LRS \
              --allow-blob-public-access false
          else
            echo "Storage account already exists"
          fi

          # Container
          if ! az storage container show --name "${{ env.TF_BACKEND_CONTAINER }}" --account-name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" --auth-mode login &>/dev/null; then
            echo "Creating container..."
            az storage container create \
              --name "${{ env.TF_BACKEND_CONTAINER }}" \
              --account-name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
              --auth-mode login
          else
            echo "Container already exists"
          fi

      - name: Backend Summary
        run: |
          echo "## Backend Infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Group | \`${{ env.TF_BACKEND_RESOURCE_GROUP }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Storage Account | \`${{ env.TF_BACKEND_STORAGE_ACCOUNT }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Container | \`${{ env.TF_BACKEND_CONTAINER }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | Ready |" >> $GITHUB_STEP_SUMMARY

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: setup-backend
    outputs:
      tfplan_exitcode: ${{ steps.plan.outputs.exitcode }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ env.TF_BACKEND_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ env.TF_BACKEND_CONTAINER }}" \
            -backend-config="key=terraform.tfstate"

      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: ./terraform
        continue-on-error: true
        run: |
          terraform plan -detailed-exitcode -no-color -out tfplan \
            -var="environment=${{ env.TF_VAR_environment }}" \
            -var="location=${{ env.TF_VAR_location }}" \
            -var="resource_group_name=${{ env.TF_VAR_resource_group_name }}" \
            -var="naming_prefix=${{ env.TF_VAR_naming_prefix }}"
          echo "exitcode=$?" >> $GITHUB_OUTPUT

      - name: Check Plan Status
        if: steps.plan.outputs.exitcode == '1'
        run: |
          echo "## Terraform Plan Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The plan encountered errors. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
          exit 1

      - uses: actions/upload-artifact@v4
        if: steps.plan.outputs.exitcode != '1'
        with:
          name: tfplan
          path: ./terraform/tfplan

      - name: Plan Summary
        if: always()
        run: |
          if [ "${{ steps.plan.outputs.exitcode }}" == "0" ]; then
            STATUS="No changes detected"
            NEXT_STEP="Will verify infrastructure"
          elif [ "${{ steps.plan.outputs.exitcode }}" == "2" ]; then
            STATUS="Changes detected"
            NEXT_STEP="Will proceed to apply"
          else
            STATUS="Plan failed"
            NEXT_STEP="Fix errors and retry"
          fi

          echo "## Terraform Plan $ICON" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Status | **$STATUS** |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ env.TF_VAR_environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Location | ${{ env.TF_VAR_location }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Next Step | $NEXT_STEP |" >> $GITHUB_STEP_SUMMARY

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: |
      always() && (
        needs.terraform-plan.outputs.tfplan_exitcode == '2' ||
        github.event_name == 'push'
      )
    outputs:
      resource_group_name: ${{ steps.terraform.outputs.resource_group_name }}
      aks_cluster_name: ${{ steps.terraform.outputs.aks_cluster_name }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: ./terraform

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ env.TF_BACKEND_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ env.TF_BACKEND_CONTAINER }}" \
            -backend-config="key=terraform.tfstate"

      - name: Import Resource Group if needed
        working-directory: ./terraform
        run: |
          # Check if RG exists in Azure but not in state
          if az group show --name "${{ env.TF_VAR_resource_group_name }}" &>/dev/null; then
            if ! terraform state show module.resource_group.azurerm_resource_group.main &>/dev/null; then
              echo "Importing existing resource group into state..."
              terraform import \
                -var="environment=${{ env.TF_VAR_environment }}" \
                -var="location=${{ env.TF_VAR_location }}" \
                -var="resource_group_name=${{ env.TF_VAR_resource_group_name }}" \
                -var="naming_prefix=${{ env.TF_VAR_naming_prefix }}" \
                module.resource_group.azurerm_resource_group.main \
                "/subscriptions/${{ env.ARM_SUBSCRIPTION_ID }}/resourceGroups/${{ env.TF_VAR_resource_group_name }}"
              echo "Resource group imported successfully"

              # Create new plan after import
              echo "Creating new plan after import..."
              terraform plan -no-color -out tfplan \
                -var="environment=${{ env.TF_VAR_environment }}" \
                -var="location=${{ env.TF_VAR_location }}" \
                -var="resource_group_name=${{ env.TF_VAR_resource_group_name }}" \
                -var="naming_prefix=${{ env.TF_VAR_naming_prefix }}"
              echo "New plan created"
            else
              echo "Resource group already in state"
            fi
          else
            echo "Resource group will be created"
          fi

      - name: Import Key Vault Access Policy if needed
        working-directory: ./terraform
        continue-on-error: true
        run: |
          # Get AKS managed identity object ID
          AKS_NAME="aks-${{ env.TF_VAR_naming_prefix }}"
          if az aks show --name "$AKS_NAME" --resource-group "${{ env.TF_VAR_resource_group_name }}" &>/dev/null; then
            AKS_IDENTITY_ID=$(az aks show --name "$AKS_NAME" --resource-group "${{ env.TF_VAR_resource_group_name }}" --query "identityProfile.kubeletidentity.objectId" -o tsv 2>/dev/null || echo "")

            if [ ! -z "$AKS_IDENTITY_ID" ]; then
              echo "Found AKS managed identity: $AKS_IDENTITY_ID"

              # Check if access policy exists in Azure but not in state
              KV_NAME=$(az keyvault list --resource-group "${{ env.TF_VAR_resource_group_name }}" --query "[?!contains(name, 'tfstate')].name" --output tsv | head -1)

              if [ ! -z "$KV_NAME" ]; then
                echo "Found Key Vault: $KV_NAME"

                if ! terraform state show module.key_vault.azurerm_key_vault_access_policy.aks_managed_identity[0] &>/dev/null; then
                  echo "Importing Key Vault access policy..."
                  terraform import \
                    -var="environment=${{ env.TF_VAR_environment }}" \
                    -var="location=${{ env.TF_VAR_location }}" \
                    -var="resource_group_name=${{ env.TF_VAR_resource_group_name }}" \
                    -var="naming_prefix=${{ env.TF_VAR_naming_prefix }}" \
                    module.key_vault.azurerm_key_vault_access_policy.aks_managed_identity[0] \
                    "/subscriptions/${{ env.ARM_SUBSCRIPTION_ID }}/resourceGroups/${{ env.TF_VAR_resource_group_name }}/providers/Microsoft.KeyVault/vaults/$KV_NAME/objectId/$AKS_IDENTITY_ID" || echo "Import failed, continuing..."

                  # Create new plan after import
                  echo "Creating new plan after Key Vault import..."
                  terraform plan -no-color -out tfplan \
                    -var="environment=${{ env.TF_VAR_environment }}" \
                    -var="location=${{ env.TF_VAR_location }}" \
                    -var="resource_group_name=${{ env.TF_VAR_resource_group_name }}" \
                    -var="naming_prefix=${{ env.TF_VAR_naming_prefix }}"
                  echo "New plan created after import"
                else
                  echo "Key Vault access policy already in state"
                fi
              fi
            fi
          fi

      - name: Terraform Apply
        id: terraform
        working-directory: ./terraform
        run: |
          terraform apply -auto-approve tfplan
          echo "resource_group_name=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT

      - name: Configure Application Gateway Backend Pool
        working-directory: ./terraform
        run: |
          # Get AKS credentials to query nodes
          AKS_NAME="aks-${{ env.TF_VAR_naming_prefix }}"
          az aks get-credentials --resource-group "${{ env.TF_VAR_resource_group_name }}" --name "$AKS_NAME" --overwrite-existing

          # Wait for nodes to be ready
          kubectl wait --for=condition=ready node --all --timeout=300s || echo "Some nodes not ready yet"

          # Get all AKS node internal IPs
          NODE_IPS=$(kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}' | tr ' ' '\n' | sort | tr '\n' ' ')

          if [ ! -z "$NODE_IPS" ]; then
            echo "Found AKS node IPs: $NODE_IPS"

            # Update Application Gateway backend pool
            APP_GW_NAME="appgw-${{ env.TF_VAR_naming_prefix }}"
            az network application-gateway address-pool update \
              --gateway-name "$APP_GW_NAME" \
              --resource-group "${{ env.TF_VAR_resource_group_name }}" \
              --name "appgw-beap" \
              --servers $NODE_IPS

            echo "Application Gateway backend pool updated with AKS node IPs"
          else
            echo "No AKS nodes found"
          fi

      - name: Apply Summary
        run: |
          echo "## Infrastructure Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ env.TF_VAR_environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Location | ${{ env.TF_VAR_location }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Group | \`${{ steps.terraform.outputs.resource_group_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | \`${{ steps.terraform.outputs.aks_cluster_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Next: ArgoCD installation" >> $GITHUB_STEP_SUMMARY

  install-argocd:
    name: Install ArgoCD
    runs-on: ubuntu-latest
    needs: [terraform-plan, terraform-apply]
    if: always() && needs.terraform-plan.result == 'success' && needs.terraform-apply.result == 'success'
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Verify AKS exists
        run: |
          RESOURCE_GROUP="${{ env.TF_VAR_resource_group_name }}"
          AKS_NAME="aks-${{ env.TF_VAR_naming_prefix }}"

          echo "Checking if AKS cluster exists: $AKS_NAME in $RESOURCE_GROUP"

          if ! az aks show --name "$AKS_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
            echo "ERROR: AKS cluster not found!"
            exit 1
          else
            echo "AKS cluster found and ready"
          fi

      - name: Get AKS Credentials
        run: |
          # Get values from environment variables instead of job outputs
          RESOURCE_GROUP="${{ env.TF_VAR_resource_group_name }}"
          AKS_NAME="aks-${{ env.TF_VAR_naming_prefix }}"

          echo "Getting credentials for AKS cluster: $AKS_NAME in resource group: $RESOURCE_GROUP"

          az aks get-credentials \
            --resource-group "$RESOURCE_GROUP" \
            --name "$AKS_NAME" \
            --overwrite-existing

      - name: Wait for AKS nodes to be ready
        run: |
          echo "Waiting for AKS nodes to be ready..."
          kubectl wait --for=condition=ready node --all --timeout=600s || {
            echo "Nodes not ready, checking status..."
            kubectl get nodes -o wide
            kubectl describe nodes
            exit 1
          }

          echo "Checking node resources..."
          kubectl top nodes || echo "Metrics not yet available"
          kubectl get nodes -o custom-columns=NAME:.metadata.name,CPU:.status.capacity.cpu,MEMORY:.status.capacity.memory

      - name: Check if ArgoCD is already installed
        id: argocd_check
        run: |
          if kubectl get namespace argocd &>/dev/null; then
            echo "ArgoCD namespace exists, checking deployment status..."

            # Check ArgoCD server (deployment)
            SERVER_READY=false
            if kubectl get deployment argocd-server -n argocd &>/dev/null; then
              READY=$(kubectl get deployment argocd-server -n argocd -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
              DESIRED=$(kubectl get deployment argocd-server -n argocd -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
              if [ "$READY" == "$DESIRED" ] && [ "$READY" != "0" ]; then
                SERVER_READY=true
              fi
            fi

            # Check ArgoCD application controller (statefulset)
            CONTROLLER_READY=false
            if kubectl get statefulset argocd-application-controller -n argocd &>/dev/null; then
              READY=$(kubectl get statefulset argocd-application-controller -n argocd -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
              DESIRED=$(kubectl get statefulset argocd-application-controller -n argocd -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
              if [ "$READY" == "$DESIRED" ] && [ "$READY" != "0" ]; then
                CONTROLLER_READY=true
              fi
            fi

            if [ "$SERVER_READY" == "true" ] && [ "$CONTROLLER_READY" == "true" ]; then
              echo "ArgoCD is already installed and running"
              echo "skip_install=true" >> $GITHUB_OUTPUT
            else
              echo "ArgoCD is installed but not ready, will reinstall"
              echo "skip_install=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "ArgoCD not installed, will install"
            echo "skip_install=false" >> $GITHUB_OUTPUT
          fi

      - name: Install ArgoCD
        if: steps.argocd_check.outputs.skip_install == 'false'
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for ArgoCD
        if: steps.argocd_check.outputs.skip_install == 'false'
        run: |
          # Function to wait for resource with retries
          wait_for_resource() {
            local resource_type=$1
            local resource_name=$2
            local namespace=$3
            local max_attempts=$4
            local wait_seconds=$5

            echo "Waiting for $resource_type/$resource_name..."

            for attempt in $(seq 1 $max_attempts); do
              echo "Attempt $attempt/$max_attempts..."

              if kubectl get $resource_type $resource_name -n $namespace &>/dev/null; then
                # Check if pods are ready
                if [ "$resource_type" == "deployment" ]; then
                  READY=$(kubectl get deployment $resource_name -n $namespace -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
                  DESIRED=$(kubectl get deployment $resource_name -n $namespace -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
                elif [ "$resource_type" == "statefulset" ]; then
                  READY=$(kubectl get statefulset $resource_name -n $namespace -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
                  DESIRED=$(kubectl get statefulset $resource_name -n $namespace -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
                fi

                if [ "$READY" == "$DESIRED" ] && [ "$READY" != "0" ]; then
                  echo "✓ $resource_type/$resource_name is ready ($READY/$DESIRED replicas)"
                  return 0
                fi

                echo "  Status: $READY/$DESIRED replicas ready, waiting..."
              else
                echo "  Resource not found yet..."
              fi

              [ $attempt -lt $max_attempts ] && sleep $wait_seconds
            done

            echo "✗ Timeout waiting for $resource_type/$resource_name"
            kubectl get pods -n $namespace -l app.kubernetes.io/name=$resource_name || true
            return 1
          }

          # Wait for ArgoCD components
          wait_for_resource "deployment" "argocd-server" "argocd" 5 60 || exit 1
          wait_for_resource "deployment" "argocd-repo-server" "argocd" 5 60 || exit 1
          wait_for_resource "deployment" "argocd-redis" "argocd" 5 30 || exit 1
          wait_for_resource "statefulset" "argocd-application-controller" "argocd" 10 60 || {
            echo "Application controller timeout, checking if it's actually running..."
            POD_STATUS=$(kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-application-controller -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "Unknown")
            POD_READY=$(kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-application-controller -o jsonpath='{.items[0].status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "False")

            if [ "$POD_STATUS" == "Running" ] && [ "$POD_READY" == "True" ]; then
              echo "Pod is running and ready despite StatefulSet timeout - continuing"
            else
              echo "Pod is not ready. Status: $POD_STATUS, Ready: $POD_READY"
              kubectl logs -n argocd -l app.kubernetes.io/name=argocd-application-controller --tail=50 || true
              exit 1
            fi
          }

          echo "✓ All ArgoCD components are ready!"

      - name: Install External Secrets Operator
        run: |
          echo "Installing External Secrets Operator..."

          # Add Helm repository
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update

          # Check if already installed
          if helm list -n external-secrets-system | grep -q external-secrets; then
            echo "External Secrets Operator already installed"
          else
            # Install External Secrets Operator
            helm install external-secrets external-secrets/external-secrets \
              --namespace external-secrets-system \
              --create-namespace \
              --set installCRDs=true \
              --wait \
              --timeout 5m

            echo "✓ External Secrets Operator installed successfully"
          fi

          # Verify CRDs are installed
          echo "Verifying External Secrets CRDs..."
          kubectl get crd | grep external-secrets || {
            echo "✗ External Secrets CRDs not found!"
            exit 1
          }

          echo "✓ External Secrets Operator is ready!"

      - name: Configure ArgoCD Applications
        run: |
          # Get Key Vault information first
          RESOURCE_GROUP="${{ env.TF_VAR_resource_group_name }}"
          KEY_VAULT_NAME=$(az keyvault list --resource-group "$RESOURCE_GROUP" --query "[?!contains(name, 'tfstate')].name" --output tsv | head -1)
          KEY_VAULT_URI=$(az keyvault show --name "$KEY_VAULT_NAME" --resource-group "$RESOURCE_GROUP" --query "properties.vaultUri" --output tsv)
          TENANT_ID=$(az account show --query tenantId --output tsv)

          echo "Key Vault Name: $KEY_VAULT_NAME"
          echo "Key Vault URI: $KEY_VAULT_URI"
          echo "Tenant ID: $TENANT_ID"

          echo "Applying ArgoCD project..."
          kubectl apply -f argocd/project.yaml

          echo "Applying ArgoCD configuration..."
          kubectl apply -f argocd/argocd-config.yaml || echo "ArgoCD config not required or already applied"

          echo "Waiting for project to be ready..."
          sleep 10

          echo "Applying ArgoCD applications with Key Vault configuration..."

          # Apply secrets application with Key Vault parameters
          kubectl apply -f argocd/secrets-application.yaml
          kubectl patch application secrets -n argocd --type merge -p "{
            \"spec\": {
              \"source\": {
                \"helm\": {
                  \"parameters\": [
                    {\"name\": \"azure.keyVaultName\", \"value\": \"$KEY_VAULT_NAME\"},
                    {\"name\": \"azure.keyVaultUri\", \"value\": \"$KEY_VAULT_URI\"},
                    {\"name\": \"azure.tenantId\", \"value\": \"$TENANT_ID\"}
                  ]
                }
              }
            }
          }"

          # Apply MongoDB application
          kubectl apply -f argocd/mongodb-application.yaml

          # Apply todo-app application
          kubectl apply -f argocd/todo-app-application.yaml

          echo "ArgoCD applications configured successfully"

      - name: Get ArgoCD Admin Password
        id: argocd_password
        run: |
          if kubectl get secret argocd-initial-admin-secret -n argocd &>/dev/null; then
            PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
            echo "::add-mask::$PASSWORD"
            echo "password=$PASSWORD" >> $GITHUB_OUTPUT
          else
            echo "Admin secret not found - ArgoCD may be using external auth"
            echo "password=not-available" >> $GITHUB_OUTPUT
          fi

      - name: ArgoCD Summary
        run: |
          if [ "${{ steps.argocd_check.outputs.skip_install }}" == "true" ]; then
            INSTALL_STATUS="Already installed (skipped)"
          else
            INSTALL_STATUS="Newly installed"
          fi

          echo "## ArgoCD Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Installation | $INSTALL_STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "| ArgoCD Server | Deployed |" >> $GITHUB_STEP_SUMMARY
          echo "| Application Controller | Deployed |" >> $GITHUB_STEP_SUMMARY
          echo "| Project Config | Applied |" >> $GITHUB_STEP_SUMMARY
          echo "| Notifications | Applied |" >> $GITHUB_STEP_SUMMARY
          echo "| Applications | Applied |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Access ArgoCD" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Get ArgoCD URL" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get svc argocd-server -n argocd" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Login credentials" >> $GITHUB_STEP_SUMMARY
          echo "Username: admin" >> $GITHUB_STEP_SUMMARY
          echo "Password: (stored in GitHub Actions secret output)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Access ArgoCD UI via LoadBalancer IP" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor application sync status" >> $GITHUB_STEP_SUMMARY
          echo "- Configure additional applications as needed" >> $GITHUB_STEP_SUMMARY

      - name: Get Application URLs
        id: app_urls
        run: |
          echo "Getting application URLs..."

          # ArgoCD Server URL
          ARGOCD_IP=""
          ARGOCD_URL=""

          # Check if ArgoCD has LoadBalancer service (might be ClusterIP)
          ARGOCD_SERVICE_TYPE=$(kubectl get service argocd-server -n argocd -o jsonpath='{.spec.type}')

          if [ "$ARGOCD_SERVICE_TYPE" == "LoadBalancer" ]; then
            # Wait for external IP (max 5 minutes)
            echo "Waiting for ArgoCD LoadBalancer IP..."
            for i in {1..30}; do
              ARGOCD_IP=$(kubectl get service argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              if [ ! -z "$ARGOCD_IP" ] && [ "$ARGOCD_IP" != "null" ]; then
                break
              fi
              echo "Waiting for IP... ($i/30)"
              sleep 10
            done

            if [ ! -z "$ARGOCD_IP" ] && [ "$ARGOCD_IP" != "null" ]; then
              ARGOCD_URL="https://$ARGOCD_IP"
            else
              ARGOCD_URL="LoadBalancer IP not yet assigned"
            fi
          else
            ARGOCD_URL="ClusterIP service - use port-forward: kubectl port-forward svc/argocd-server -n argocd 8080:443"
          fi

          echo "argocd_url=$ARGOCD_URL" >> $GITHUB_OUTPUT
          echo "ArgoCD URL: $ARGOCD_URL"

          # Todo App URL
          TODO_APP_URL=""
          TODO_ACCESS_INSTRUCTIONS=""

          # Check in both todo-app namespace and default namespace
          for NAMESPACE in "todo-app" "default"; do
            if kubectl get namespace "$NAMESPACE" &>/dev/null; then
              # Look for todo-app service
              if kubectl get service -n "$NAMESPACE" -l app.kubernetes.io/name=todo-app &>/dev/null 2>&1; then
                TODO_SERVICE_TYPE=$(kubectl get service -n "$NAMESPACE" -l app.kubernetes.io/name=todo-app -o jsonpath='{.items[0].spec.type}' 2>/dev/null || echo "")
                SERVICE_NAME=$(kubectl get service -n "$NAMESPACE" -l app.kubernetes.io/name=todo-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "todo-app")

                if [ "$TODO_SERVICE_TYPE" == "LoadBalancer" ]; then
                  TODO_IP=$(kubectl get service -n "$NAMESPACE" -l app.kubernetes.io/name=todo-app -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
                  if [ ! -z "$TODO_IP" ] && [ "$TODO_IP" != "null" ]; then
                    TODO_APP_URL="http://$TODO_IP"
                    TODO_ACCESS_INSTRUCTIONS="Direct access via LoadBalancer IP"
                  else
                    TODO_APP_URL="LoadBalancer IP not yet assigned"
                    TODO_ACCESS_INSTRUCTIONS="Wait for external IP: kubectl get svc -n $NAMESPACE $SERVICE_NAME -w"
                  fi
                elif [ "$TODO_SERVICE_TYPE" == "ClusterIP" ]; then
                  TODO_APP_URL="ClusterIP service"
                  TODO_ACCESS_INSTRUCTIONS="Port-forward: kubectl port-forward svc/$SERVICE_NAME -n $NAMESPACE 8080:80"
                else
                  TODO_APP_URL="Service found but type unknown: $TODO_SERVICE_TYPE"
                  TODO_ACCESS_INSTRUCTIONS="Check service: kubectl get svc -n $NAMESPACE $SERVICE_NAME -o yaml"
                fi
                break # Found service, exit loop
              else
                # Check for ingress in this namespace
                if kubectl get ingress -n "$NAMESPACE" -l app.kubernetes.io/name=todo-app &>/dev/null 2>&1; then
                  INGRESS_HOST=$(kubectl get ingress -n "$NAMESPACE" -l app.kubernetes.io/name=todo-app -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "")
                  INGRESS_NAME=$(kubectl get ingress -n "$NAMESPACE" -l app.kubernetes.io/name=todo-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "todo-app")
                  if [ ! -z "$INGRESS_HOST" ] && [ "$INGRESS_HOST" != "null" ]; then
                    TODO_APP_URL="http://$INGRESS_HOST"
                    TODO_ACCESS_INSTRUCTIONS="Access via Ingress host"
                  else
                    TODO_APP_URL="Ingress configured"
                    TODO_ACCESS_INSTRUCTIONS="Check ingress: kubectl get ingress -n $NAMESPACE $INGRESS_NAME -o yaml"
                  fi
                  break # Found ingress, exit loop
                fi
              fi
            fi
          done

          # If no service or ingress found
          if [ -z "$TODO_APP_URL" ]; then
            TODO_APP_URL="Not deployed yet"
            TODO_ACCESS_INSTRUCTIONS="Check ArgoCD sync status: kubectl get app todo-app -n argocd"
          fi

          echo "todo_app_url=$TODO_APP_URL" >> $GITHUB_OUTPUT
          echo "todo_access_instructions=$TODO_ACCESS_INSTRUCTIONS" >> $GITHUB_OUTPUT
          echo "Todo App URL: $TODO_APP_URL"
          echo "Access Instructions: $TODO_ACCESS_INSTRUCTIONS"

      - name: Final Summary
        run: |
          echo "##Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Access Your Applications" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Application | URL | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| **ArgoCD** | \`${{ steps.app_urls.outputs.argocd_url }}\` | Ready |" >> $GITHUB_STEP_SUMMARY
          echo "| **Todo App** | \`${{ steps.app_urls.outputs.todo_app_url }}\` | Check ArgoCD |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "###How to Access Todo App" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** \`${{ steps.app_urls.outputs.todo_app_url }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Access Method:** ${{ steps.app_urls.outputs.todo_access_instructions }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.app_urls.outputs.todo_app_url }}" == *"http"* ]]; then
            echo "**Direct URL:** ${{ steps.app_urls.outputs.todo_app_url }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo "### Quick Commands" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Connect to AKS" >> $GITHUB_STEP_SUMMARY
          echo "az aks get-credentials --resource-group ${{ env.TF_VAR_resource_group_name }} --name aks-${{ env.TF_VAR_naming_prefix }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Port-forward ArgoCD (if needed)" >> $GITHUB_STEP_SUMMARY
          echo "kubectl port-forward svc/argocd-server -n argocd 8080:443" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check application status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get apps -n argocd" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get pods,svc,ingress -n todo-app" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Access Todo App (if deployed)" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.app_urls.outputs.todo_access_instructions }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ArgoCD Login" >> $GITHUB_STEP_SUMMARY
          echo "- **Username:** \`admin\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Password:** Check GitHub Actions logs or run:" >> $GITHUB_STEP_SUMMARY
          echo "  \`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 --decode; echo\`" >> $GITHUB_STEP_SUMMARY